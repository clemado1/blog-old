---
layout: post
title: 소금값을 이용한 패스워드 암호화
excerpt_separator: <!--more-->
---
쇼핑몰 사이트를 처음 구상할 때 부터 완벽하게는 아니더라도 어느정도 보안을 신경쓴, 실제와 가까운 사이트를 만들고 싶었다. 그래서 비밀번호 찾기 페이지를 구성할 때 여러 사이트를 참고했다. 대부분 임시 비밀번호를 이용하거나 그냥 새로운 비밀번호로 바꾸도록 구현했더랬다. 그냥 생각해봐도 찾고자하는 비밀번호를 떡하니 알려주는 건 위험해보이긴 한다. 하지만 나는 구체적으로 왜 그렇게 하는지가 궁금했다. 대체 왜?

사실 기억속에 존재하는 어느 예전 사이트 중에는 비밀번호 찾기를 했을 때 그냥 비밀번호를 알려주는 사이트도 있었다. 지금도 소수 있다고 하긴 한다. 이런 사이트의 문제는 클라이언트에 비밀번호를 노출한다는 피상적인 문제뿐만 아니라 DB에 접근했을 때 사용자가 입력한 **비밀번호 원본**을 그대로 알 수 있다는 치명적인 오점이 존재한다. 누군가 비밀을 발설할 것이 두렵다면 그냥 비밀을 알려주지 않으면 된다. 그러니까 비밀번호도 마찬가지다. 비밀번호는 DB에 그 누구도 모르게끔 저장되어야 한다.

 즉 비밀번호는 회원가입 처리할 때 암호화를 거친 다음 DB에 저장해야한다. 비밀번호 암호화는 주로 **SHA**방식과 **RSA**방식을 사용하는데 나는 암호화 해시 함수인 SHA중에서도 **SHA-256**을 사용했다.  
 그런데 여기서 또 문제가 발생한다. '암호화 함수'를 사용한다는 건 INPUT이 같다면 OUTPUT도 같다는 말이 된다. 만약에 서로 다른 유저가 똑같은 비밀번호를 사용한다면 암호화 한 비밀번호도 똑같을 수 밖에 없다. 이렇게 되면 일종의 *패턴* 이 생긴다. 비밀번호 하나를 알아내면 다른 비밀번호를 뚫거나 유추할 수 있다.  
 해시 예시값을 대량으로 가지고 있는 *룩업 테이블*이나 *레인보우 테이블* 만 있으면 이런 비밀번호 다발은 손쉽게 뚫린다. 이런 공격을 막기 위해서 사용하는 게 바로 **소금값 SALT**다. 사용은 간단하다. 암호화하고자 하는 비밀번호 앞 혹은 뒤에 임의로 생성한 **소금값**을 붙여준 다음 암호화하면 된다. 이렇게 하면 똑같은 비밀번호일지라도 DB에는 다르게 저장된다.
 
**소금값**은 회원가입 할 때 각 회원 고유의 *user salt*값을 생성하고 DB에 저장하는 방식으로 쓰면 된다. 소금값은 유일성을 반드시 충족해야하고 또 비밀번호의 암호화에 사용되기 때문에 *Random*클래스보다 강력한 *SecureRandom*클래스를 사용한다. *SecureRandom*은 똑같은 값이 나올 확률이 극히 적으며, 랜덤값을 운영체제에서 가져오기 때문에 값을 미리 알 수 없다. (이론적으로는 가능하지만 매우 오래걸린다고 한다.) 소금값을 만들고 나면 이 값은 DB에 그대로 저장해도 되는건지 의문이 생길 수 있는데 (나도 그랬고) 소금값은 암호의 패턴화와 추측을 막는 용도기 때문에 따로 암호화 할 필요없이 저장해도 무방하다.  
소금값의 길이는 너무 짧지 않게, 되도록이면 암호화한 비밀번호의 길이와 같도록 만든다. 나는 32byte인 SHA-256을 사용했으므로 소금값또한 32byte의 크기로 만들었다. 소금값은 회원가입 시 최초로 생성하고 그대로 유지하지만 유저가 비밀번호를 바꿀 때는 소금값도 같이 바꿔주는 게 좋다. [참고](http://starplatina.tistory.com/entry/%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8-%ED%95%B4%EC%8B%9C%EC%97%90-%EC%86%8C%EA%B8%88%EC%B9%98%EA%B8%B0-%EB%B0%94%EB%A5%B4%EA%B2%8C-%EC%93%B0%EA%B8%B0)
  


- - -

  
코드는 비전문가인 내가 인터넷에 올라와있는 코드 여러개를 조합해서 만들었기 때문에 그냥 참고만 하는 게 좋겠다.  

######소금값을 생성하는 메소드######
```
public static String getSalt() {
		String usalt= null;
		try {
			SecureRandom sr = new SecureRandom();
			byte[] salt = new byte[32];
			sr.nextBytes(salt);
			StringBuilder sb = new StringBuilder();
			 for(int i=0; i<salt.length; i++) {
			  sb.append(Integer.toString((salt[i]&0xff)+0x100,16).substring(1)); 
			 }
			 usalt = sb.toString();
		}catch(Exception e) {
			e.printStackTrace();
		}
		return usalt;
	}
```
  
  
  

######소금값을 이용해 비밀번호를 암호화하는 메소드######
```
public static String getPassword(String password, String salt) {
		String codedPassword = null;
		
		try {
			MessageDigest md = MessageDigest.getInstance("SHA-256");
			md.reset();
			md.update(salt.getBytes());
			byte[] bytes = md.digest(password.getBytes("UTF-8"));
			StringBuilder sb = new StringBuilder();
			for(int i=0;i<bytes.length;i++) {
				sb.append(Integer.toString((bytes[i]&0xff)+0x100,16).substring(1));
			}
			codedPassword= sb.toString();
		}catch(Exception e) {
			e.printStackTrace();
		}
		return codedPassword;
	}
```
  
  
여기에서,
`sb.append(Integer.toString((bytes[i]&0xff)+0x100,16).substring(1));`
이 연산이 어렵게 보일 수도 있다. byte를 int형으로 변환할 때 8bit가 32bit가 되면서 앞 bit들이 0이나 1로 채워진다. 변환값의 첫 bit가 0이라면 나머지가 0으로 채워지고 동일한 값이 나오지만 첫 bit가 1이라면 보수법에 의해 나머지가 1로 채워지고, 원래 값과 다른 값이 나온다. 이를 방지하기 위해 *0xff*를 비트마스크로 사용하는 것이다. 그리고 *0x100*는 두 자리 통일을 위해서 사용한다. 1~15의 수는 ++1,2,3 ... .d,e,f++ 한 자리만 갖기 때문에 0x100을 더해서 ++101,102,103 .... 10d,10e,10f++로 만든 다음 가장 앞의 1을 없애기 위해 *substring(1)*을 사용한다. [참고](http://javaslave.tistory.com/59)



